/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : addresses
 #	author : miyako
 #	2017/05/22
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#pragma mark Startup / Exit

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnExit()
{
#if VERSIONWIN
	WSACleanup();
#endif
}

void OnCloseProcess()
{
	if(IsProcessOnExit())
	{
		OnExit();
	}
}

void OnStartup()
{
#if VERSIONWIN
	WSAData data;
	WSAStartup(MAKEWORD(2,0), &data);
#endif
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
#if VERSIONWIN
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
#endif
			// --- addresses

		case 1 :
			IP_ADDRESS_LIST(pResult, pParams);
			break;

	}
}

// ----------------------------------- addresses ----------------------------------

typedef enum
{
	AddressTypeBoth     = 0,
	AddressTypeIPv4     = 1,
	AddressTypeIPv6     = 23
} address_type_t;

#if VERSIONWIN
#include <iphlpapi.h>
#pragma comment(lib, "IPHLPAPI.lib")
#endif

void IP_ADDRESS_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1;
	C_LONGINT Param2;

	Param2.fromParamAtIndex(pParams, 2);
	
	
#if VERSIONWIN
	DWORD dwSize = 0;
	DWORD dwRetVal = 0;
	unsigned int i = 0;
	// Set the flags to pass to GetAdaptersAddresses
	ULONG flags = GAA_FLAG_INCLUDE_PREFIX| GAA_FLAG_SKIP_FRIENDLY_NAME;
	// default to unspecified address family (both)
	ULONG family = family = (ULONG)Param2.getIntValue();
	switch (family)
	{
	case AddressTypeBoth:
	case AddressTypeIPv6:
		break;
	case AddressTypeIPv4:
		family = AF_INET;//my bad!
		break;
	default:
		family = 1;//invalid flag
		break;
	}

	if (family != 1)
	{
		PIP_ADAPTER_ADDRESSES pAddresses = NULL;
		PIP_ADAPTER_ADDRESSES pCurrAddresses = NULL;
		PIP_ADAPTER_UNICAST_ADDRESS pUnicast = NULL;

		DWORD size = 0;
		DWORD rv = GetAdaptersAddresses(family, flags, NULL, NULL, &size);
		if (rv == ERROR_BUFFER_OVERFLOW)
		{
			std::vector<uint8_t>buf(size);
			pAddresses = (IP_ADAPTER_ADDRESSES *)&buf[0];
			rv = GetAdaptersAddresses(family, flags, NULL, pAddresses, &size);
			if (rv == ERROR_SUCCESS)
			{
				for (pCurrAddresses = pAddresses; pCurrAddresses != NULL; pCurrAddresses = pCurrAddresses->Next)
				{
					if (pCurrAddresses->IfType != IF_TYPE_SOFTWARE_LOOPBACK)
					{
						for (pUnicast = pCurrAddresses->FirstUnicastAddress; pUnicast != NULL; pUnicast = pUnicast->Next)
						{
							if (pUnicast->Flags & IP_ADAPTER_ADDRESS_DNS_ELIGIBLE)
							{
								size_t buflen = pUnicast->Address.lpSockaddr->sa_family == AF_INET ? INET_ADDRSTRLEN : INET6_ADDRSTRLEN;
								std::vector<uint8_t>addrbuf(buflen);

								getnameinfo(pUnicast->Address.lpSockaddr,
									pUnicast->Address.iSockaddrLength,
									(char *)&addrbuf[0], buflen, NULL, 0, NI_NUMERICHOST);
								if (!Param1.getSize()) Param1.setSize(1);
								CUTF8String address = (const uint8_t *)&addrbuf[0];
								Param1.appendUTF8String(&address);

							}
						}
					}
				}
			}
		}
	}
#else
	address_type_t family = (address_type_t)Param2.getIntValue();
	struct ifaddrs *interfaces;
	
	if (!getifaddrs(&interfaces))
	{
		struct ifaddrs *interface;
		for (interface=interfaces; interface != NULL; interface=interface->ifa_next)
		{
			if ((interface->ifa_flags & IFF_UP) && !(interface->ifa_flags & IFF_LOOPBACK))
			{
				const struct sockaddr_in *addr = (const struct sockaddr_in *)interface->ifa_addr;
				if (addr && addr->sin_family == PF_INET)
				{
					if ((family == AddressTypeBoth) || (family == AddressTypeIPv4))
					{
						char ip4Address[INET_ADDRSTRLEN];
						inet_ntop(addr->sin_family, &(addr->sin_addr), ip4Address, INET_ADDRSTRLEN);
						
						if (!Param1.getSize()) Param1.setSize(1);
						CUTF8String address = (const uint8_t *)ip4Address;
						Param1.appendUTF8String(&address);
					}
				}else if (addr && addr->sin_family == PF_INET6)
				{
					if ((family == AddressTypeBoth) || (family == AddressTypeIPv6))
					{
						char ip6Address[INET6_ADDRSTRLEN];
						inet_ntop( addr->sin_family, &(addr->sin_addr), ip6Address, INET6_ADDRSTRLEN );
						if (!Param1.getSize()) Param1.setSize(1);
						CUTF8String address = (const uint8_t *)ip6Address;
						Param1.appendUTF8String(&address);
					}
				}
			}
		}
	}
	//credit: http://stackoverflow.com/questions/3266428/accessing-ip-address-with-nshost
#endif
	Param1.toParamAtIndex(pParams, 1);
}

