/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : addresses
 #	author : miyako
 #	2017/05/22
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#pragma mark Startup / Exit

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnExit()
{
#if VERSIONWIN
	WSACleanup();
#endif
}

void OnCloseProcess()
{
	if(IsProcessOnExit())
	{
		OnExit();
	}
}

void OnStartup()
{
#if VERSIONWIN
	WSAData data;
	WSAStartup(MAKEWORD(2,0), &data);
#endif
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
#if VERSIONWIN
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
#endif
			// --- addresses

		case 1 :
			IP_ADDRESS_LIST(pResult, pParams);
			break;

	}
}

// ----------------------------------- addresses ----------------------------------

typedef enum
{
	AddressTypeBoth     = 0,
	AddressTypeIPv4     = 2,
	AddressTypeIPv6     = 23
} address_type_t;

#if VERSIONWIN
#include <iphlpapi.h>
#pragma comment(lib, "IPHLPAPI.lib")
#else
#include <SystemConfiguration/SCNetworkConfiguration.h>
#endif

void IP_ADDRESS_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1;
	ARRAY_TEXT Param2;
	C_LONGINT Param3;

	Param3.fromParamAtIndex(pParams, 3);
	
#if VERSIONWIN
	ULONG flags = GAA_FLAG_INCLUDE_PREFIX| GAA_FLAG_SKIP_FRIENDLY_NAME;
	ULONG family = family = (ULONG)Param3.getIntValue();
	switch (family)
	{
	case AddressTypeBoth:
	case AddressTypeIPv6:
	case AddressTypeIPv4:
			break;
	default:
		family = 1;//invalid flag
		break;
	}

	if (family != 1)
	{
		PIP_ADAPTER_ADDRESSES pAddresses = NULL;
		PIP_ADAPTER_ADDRESSES pCurrAddresses = NULL;
		PIP_ADAPTER_UNICAST_ADDRESS pUnicast = NULL;

		DWORD size = 0;
		DWORD rv = GetAdaptersAddresses(family, flags, NULL, NULL, &size);
		if (rv == ERROR_BUFFER_OVERFLOW)
		{
			std::vector<uint8_t>buf(size);
			pAddresses = (IP_ADAPTER_ADDRESSES *)&buf[0];
			rv = GetAdaptersAddresses(family, flags, NULL, pAddresses, &size);
			if (rv == ERROR_SUCCESS)
			{
				for (pCurrAddresses = pAddresses; pCurrAddresses != NULL; pCurrAddresses = pCurrAddresses->Next)
				{
					if (pCurrAddresses->IfType != IF_TYPE_SOFTWARE_LOOPBACK)
					{
						PWCHAR friendlyName = pCurrAddresses->FriendlyName;
						
						for (pUnicast = pCurrAddresses->FirstUnicastAddress; pUnicast != NULL; pUnicast = pUnicast->Next)
						{
							if (pUnicast->Flags & IP_ADAPTER_ADDRESS_DNS_ELIGIBLE)
							{
								size_t buflen = pUnicast->Address.lpSockaddr->sa_family == AF_INET ? INET_ADDRSTRLEN : INET6_ADDRSTRLEN;
								std::vector<uint8_t>addrbuf(buflen);

								getnameinfo(pUnicast->Address.lpSockaddr,
									pUnicast->Address.iSockaddrLength,
									(char *)&addrbuf[0], buflen, NULL, 0, NI_NUMERICHOST);
								if (!Param1.getSize()) Param1.setSize(1);
								if (!Param2.getSize()) Param2.setSize(1);
								CUTF8String address = (const uint8_t *)&addrbuf[0];
								Param1.appendUTF8String(&address);
								CUTF16String name = (const PA_Unichar *)friendlyName;
								Param2.appendUTF16String(&name);
							}
						}
					}
				}
			}
		}
	}
#else
	
	NSArray * network_interfaces = (NSArray *)SCNetworkInterfaceCopyAll();
	
	address_type_t family = (address_type_t)Param3.getIntValue();
	struct ifaddrs *interfaces;
	
	if (!getifaddrs(&interfaces))
	{
		struct ifaddrs *interface;
		for (interface=interfaces; interface != NULL; interface=interface->ifa_next)
		{
			if ((interface->ifa_flags & IFF_UP) && !(interface->ifa_flags & IFF_LOOPBACK))
			{
				const struct sockaddr_in *addr = (const struct sockaddr_in *)interface->ifa_addr;
				if (addr && addr->sin_family == PF_INET)
				{
					if ((family == AddressTypeBoth) || (family == AddressTypeIPv4))
					{
						char ip4Address[INET_ADDRSTRLEN];
						inet_ntop(addr->sin_family, &(addr->sin_addr), ip4Address, INET_ADDRSTRLEN);
						
						if (!Param1.getSize()) Param1.setSize(1);
						if (!Param2.getSize()) Param2.setSize(1);
						CUTF8String address = (const uint8_t *)ip4Address;
						Param1.appendUTF8String(&address);
						CUTF8String name = (const uint8_t *)interface->ifa_name;
						Param2.appendUTF8String(&name);
						
					}
				}else if (addr && addr->sin_family == PF_INET6)
				{
					if ((family == AddressTypeBoth) || (family == AddressTypeIPv6))
					{
						char ip6Address[INET6_ADDRSTRLEN];
						inet_ntop(addr->sin_family, &(addr->sin_addr), ip6Address, INET6_ADDRSTRLEN);
						if (!Param1.getSize()) Param1.setSize(1);
						if (!Param2.getSize()) Param2.setSize(1);
						CUTF8String address = (const uint8_t *)ip6Address;
						Param1.appendUTF8String(&address);
						NSString *ifa_name = [[NSString alloc]initWithUTF8String:(const char *)interface->ifa_name];
						NSUInteger i = [network_interfaces indexOfObjectPassingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop)
						{
							SCNetworkInterfaceRef network_interface = (SCNetworkInterfaceRef)obj;
							
							NSString *bsd_name = (NSString *)SCNetworkInterfaceGetBSDName(network_interface);
							if(bsd_name)
							{
								if ([bsd_name isEqualToString:ifa_name])
								{
									return YES;
								}
							}
							return NO;
						}];
						
						if(NSNotFound != i)
						{
							NSString *displayName = (NSString *)SCNetworkInterfaceGetLocalizedDisplayName((SCNetworkInterfaceRef)[network_interfaces objectAtIndex:i]);
							Param2.appendUTF16String(displayName);
						}else
						{
							Param2.appendUTF16String(ifa_name);
						}
						[ifa_name release];
					}
				}
			}
		}
	}
	//credit: http://stackoverflow.com/questions/3266428/accessing-ip-address-with-nshost
	
	[network_interfaces release];
#endif
	Param1.toParamAtIndex(pParams, 1);
	Param2.toParamAtIndex(pParams, 2);
}

